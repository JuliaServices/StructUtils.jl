<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · StructUtils.jl</title><meta name="title" content="API Reference · StructUtils.jl"/><meta property="og:title" content="API Reference · StructUtils.jl"/><meta property="twitter:title" content="API Reference · StructUtils.jl"/><meta name="description" content="Documentation for StructUtils.jl."/><meta property="og:description" content="Documentation for StructUtils.jl."/><meta property="twitter:description" content="Documentation for StructUtils.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">StructUtils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">StructUtils.jl Documentation</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaServices/StructUtils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaServices/StructUtils.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><ul><li><a href="../#StructUtils.jl-Documentation">StructUtils.jl Documentation</a></li><li class="no-marker"><ul><li><a href="../#Installation">Installation</a></li><li><a href="../#Quick-Start">Quick Start</a></li><li><a href="../#Core-Concepts">Core Concepts</a></li><li><a href="../#Struct-Styles">Struct Styles</a></li><li><a href="../#Struct-Definition-Macros">Struct Definition Macros</a></li><li><a href="../#Field-Tags-Syntax">Field Tags Syntax</a></li><li><a href="../#The-make-Function">The <code>make</code> Function</a></li><li><a href="../#Implementing-StructUtils-Interfaces">Implementing StructUtils Interfaces</a></li><li><a href="../#Advanced-Features">Advanced Features</a></li><li><a href="../#Complex-Example">Complex Example</a></li><li><a href="../#Summary">Summary</a></li></ul></li><li><a href="#API-Reference">API Reference</a></li></ul><article><details class="docstring" open="true"><summary id="StructUtils.DefaultStyle"><a class="docstring-binding" href="#StructUtils.DefaultStyle"><code>StructUtils.DefaultStyle</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">StructUtils.DefaultStyle</code></pre><p>Default struct style that all StructUtils.jl interface methods are defined for by default.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L17-L22">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.EarlyReturn"><a class="docstring-binding" href="#StructUtils.EarlyReturn"><code>StructUtils.EarlyReturn</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">StructUtils.EarlyReturn{T}</code></pre><p>A wrapper type that can be used in function arguments to <code>applyeach</code> to short-circuit iteration and return a value from <code>applyeach</code>.</p><p>Example usage:</p><pre><code class="language-julia hljs">function find_needle_in_haystack(haystack, needle)
    ret = applyeach(haystack) do k, v
        k == needle &amp;&amp; return StructUtils.EarlyReturn(v)
    end
    ret isa StructUtils.EarlyReturn &amp;&amp; return ret.value
    throw(ArgumentError(&quot;needle not found in haystack&quot;)
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L460-L477">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.StructStyle"><a class="docstring-binding" href="#StructUtils.StructStyle"><code>StructUtils.StructStyle</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">StructUtils.StructStyle</code></pre><p>Abstract type that all concrete struct styles must subtype. Custom struct styles allow fine-grained control over various StructUtils.jl interface methods like <code>fieldtags</code>, <code>fielddefaults</code>, <code>lift</code>, <code>lower</code>, etc.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L7-L14">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.addkeyval!"><a class="docstring-binding" href="#StructUtils.addkeyval!"><code>StructUtils.addkeyval!</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.addkeyval!(d, k, v)</code></pre><p>Add a key-value pair to a dictionary-like object <code>d</code>. This function is called by <code>StructUtils.make</code> when <code>d</code> is <code>dictlike</code>. The default implementation is to call <code>d[k] = v</code> for <code>AbstractDict</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L178-L184">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.applyeach"><a class="docstring-binding" href="#StructUtils.applyeach"><code>StructUtils.applyeach</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.applyeach(style, f, x) -&gt; Union{StructUtils.EarlyReturn, Nothing}</code></pre><p>A custom <code>foreach</code>-like function that operates specifically on <code>(key, val)</code> or <code>(ind, val)</code> pairs, and supports short-circuiting (via <code>StructUtils.EarlyReturn</code>). It also supports a <code>StructStyle</code> argument to allow for style-specific behavior for non-owned types.</p><p>For each key-value or index-value pair in <code>x</code>, call <code>f(k, v)</code>. If <code>f</code> returns a <code>StructUtils.EarlyReturn</code> instance, <code>applyeach</code> should return the <code>EarlyReturn</code> immediately and stop iterating (i.e. short-circuit). Otherwise, the return value of <code>f</code> can be ignored and iteration continues.</p><p>Key types are generally expected to be Symbols, Strings, or Integers.</p><p>An example overload of <code>applyeach</code> for a generic iterable would be:</p><pre><code class="language-julia hljs">function StructUtils.applyeach(style::StructUtils.StructStyle, f, x::MyIterable)
    for (i, v) in enumerate(x)
        ret = f(StructUtils.lowerkey(style, i), StructUtils.lower(style, v))
        # if `f` returns EarlyReturn, return immediately
        ret isa StructUtils.EarlyReturn &amp;&amp; return ret
    end
    return
end</code></pre><p>Note that <code>applyeach</code> must include the <code>style</code> argument when overloading.</p><p>Also note that before applying <code>f</code>, the key or index is passed through <code>StructUtils.lowerkey(style, k)</code>, and the value <code>v</code> is passed through <code>StructUtils.lower(style, v)</code>.</p><p>If a value is <code>#undef</code> or otherwise not defined, the <code>f</code> function should generally be called with <code>nothing</code> or skipped.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L424-L457">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.arraylike"><a class="docstring-binding" href="#StructUtils.arraylike"><code>StructUtils.arraylike</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.arraylike(x) -&gt; Bool
StructUtils.arraylike(::StructStyle, x) -&gt; Bool
StructUtils.arraylike(::StructStyle, ::Type{T}) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>x</code> or type <code>T</code> is array-like, <code>false</code> otherwise. This function is called by <code>StructUtils.make</code> to determine if <code>T</code> is array-like. The default implementation returns <code>true</code> for <code>&lt;:AbstractArray</code>, <code>&lt;:AbstractSet</code>, <code>&lt;:Tuple</code>, <code>&lt;:Base.Generator</code>, and <code>&lt;:Core.SimpleVector</code> types, and <code>false</code> for <code>&lt;:AbstractArray{T,0}</code>.</p><p>Once <code>initialize</code> is called, <code>StructUtils.make</code> will call <code>push!</code> to add values to the array-like object.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L195-L207">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.defaultstate-Tuple{StructUtils.StructStyle}"><a class="docstring-binding" href="#StructUtils.defaultstate-Tuple{StructUtils.StructStyle}"><code>StructUtils.defaultstate</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">StructUtils.defaultstate(::StructStyle) -&gt; Any</code></pre><p>Returns the default state for a given struct style. This is used to initialize the state of a struct when no state is provided. The default implementation returns <code>nothing</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L109-L115">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.dictlike"><a class="docstring-binding" href="#StructUtils.dictlike"><code>StructUtils.dictlike</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.dictlike(x) -&gt; Bool
StructUtils.dictlike(::StructStyle, x) -&gt; Bool
StructUtils.dictlike(::StructStyle, ::Type{T}) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>x</code> or type <code>T</code> is dictionary-like, <code>false</code> otherwise. When <code>StructUtils.make(T, source)</code> is called, if <code>dictlike(T)</code> is <code>true</code>, an instance will be <code>initialize</code>d, and then <code>addkeyval!</code>ed for each key-value pair in <code>source</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L27-L36">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.fielddefault"><a class="docstring-binding" href="#StructUtils.fielddefault"><code>StructUtils.fielddefault</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.fielddefaults(::StructStyle, ::Type{T}) -&gt; NamedTuple
StructUtils.fielddefault(::StructStyle, ::Type{T}, fieldname) -&gt; NamedTuple</code></pre><p>Returns a <code>NamedTuple</code> of field defaults for the struct <code>T</code>. Field defaults can be added manually by overloading <code>fielddefaults</code>, or included via convenient syntax using the StructUtils.jl macros: <code>@tags</code>, <code>@noarg</code>, <code>@defaults</code>, or <code>@kwarg</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L139-L146">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.fielddefaults"><a class="docstring-binding" href="#StructUtils.fielddefaults"><code>StructUtils.fielddefaults</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.fielddefaults(::StructStyle, ::Type{T}) -&gt; NamedTuple
StructUtils.fielddefault(::StructStyle, ::Type{T}, fieldname) -&gt; NamedTuple</code></pre><p>Returns a <code>NamedTuple</code> of field defaults for the struct <code>T</code>. Field defaults can be added manually by overloading <code>fielddefaults</code>, or included via convenient syntax using the StructUtils.jl macros: <code>@tags</code>, <code>@noarg</code>, <code>@defaults</code>, or <code>@kwarg</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L139-L146">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.fieldtagkey"><a class="docstring-binding" href="#StructUtils.fieldtagkey"><code>StructUtils.fieldtagkey</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.fieldtagkey(::StructStyle) -&gt; Symbol</code></pre><p>Field tags defined on struct fields can be grouped by keys that are associated with a particular struct style. This function returns the key that should be used to retrieve field tags for a given struct style. By default, this function returns <code>nothing</code>. An example overload might look like:</p><pre><code class="language-julia hljs">struct MySQLStyle &lt;: StructStyle end

StructUtils.fieldtagkey(::MySQLStyle) = :mysql

@tags struct Foo
    a::Int &amp;(mysql=(name=&quot;foo_a&quot;,),)
    b::String
end</code></pre><p>In this example, when <code>StructUtils.make</code> is called on <code>Foo</code> with the <code>MySQLStyle</code> style, only <code>(name=&quot;foo_a&quot;,)</code> will be retrieved from the field tags for <code>a</code> because the <code>mysql</code> key is associated with the <code>MySQLStyle</code> struct style. In other words, fieldtag keys allow custom struct styles to &quot;namespace&quot; field tags so structs can overload specific tags in multiple ways for different namespaces, i.e. <code>a::Int &amp;(mysql=(name=&quot;foo_a&quot;,), json=(name=&quot;json_a&quot;,))</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L80-L104">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.fieldtags"><a class="docstring-binding" href="#StructUtils.fieldtags"><code>StructUtils.fieldtags</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.fieldtags(::StructStyle, ::Type{T}) -&gt; NamedTuple
StructUtils.fieldtags(::StructStyle, ::Type{T}, fieldname) -&gt; NamedTuple</code></pre><p>Returns a <code>NamedTuple</code> of field tags for the struct <code>T</code>. Field tags can be added manually by overloading <code>fieldtags</code>, or included via convenient syntax using the StructUtils.jl macros: <code>@tags</code>, <code>@noarg</code>, <code>@defaults</code>, or <code>@kwarg</code>. Note this function returns the tags of <em>all</em> fields as a single NamedTuple.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L118-L126">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.initialize"><a class="docstring-binding" href="#StructUtils.initialize"><code>StructUtils.initialize</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.initialize(::StructStyle, T, source) -&gt; T</code></pre><p>In <code>StructUtils.make</code>, this function is called to initialize a new instance of <code>T</code>, when <code>T</code> is <code>dictlike</code>, <code>arraylike</code>, or <code>noarg</code>. The <code>source</code> is passed from the call to <code>make</code>, and can be used for initialization if appropriate. The default implementation of <code>initialize</code> is to call <code>T()</code> or <code>T(undef, 0)</code> for <code>&lt;:AbstractArray</code> types.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L153-L161">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.kwarg"><a class="docstring-binding" href="#StructUtils.kwarg"><code>StructUtils.kwarg</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.kwarg(x) -&gt; Bool
StructUtils.kwarg(::StructStyle, x) -&gt; Bool
StructUtils.kwarg(::StructStyle, ::Type{T}) -&gt; Bool</code></pre><p>Signals that <code>x</code> or type <code>T</code> can be constructed by passing struct fields as keyword arguments to the constructor, like <code>t = T(field1=a, field2=b, ...)</code>. Automatically overloaded when structs use the <code>StructUtils.@kwarg</code> macro in their struct definition. The default value is <code>false</code> unless explicitly overloaded.</p><p>Note that <code>StructUtils.@kwarg</code> is a separate implementation of <code>Base.@kwdef</code>, yet should be a drop-in replacement for it.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L61-L73">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.lift"><a class="docstring-binding" href="#StructUtils.lift"><code>StructUtils.lift</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.lift(::Type{T}, x) -&gt; T
StructUtils.lift(::StructStyle, ::Type{T}, x) -&gt; Tuple{T, Any}</code></pre><p>Lifts a value <code>x</code> to a type <code>T</code>. This function is called by <code>StructUtils.make</code> to lift unit/atom values to the appropriate type. The default implementation is the identity function for most types, but it also includes special cases for <code>Symbol</code>, <code>Char</code>, <code>UUID</code>, <code>VersionNumber</code>, <code>MIME</code>, <code>Regex</code>, and <code>TimeType</code> types to be constructed from strings. Allows transforming a &quot;domain value&quot; that may be some primitive representation into a more complex Julia type.</p><p>The method with a <code>StructStyle</code> argument should return a tuple of the lifted value and any side-effect state derived from lifting the value.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L329-L343">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.liftkey"><a class="docstring-binding" href="#StructUtils.liftkey"><code>StructUtils.liftkey</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.liftkey(::Type{T}, x) -&gt; x
StructUtils.liftkey(style::StructStyle, ::Type{T}, x) -&gt; x</code></pre><p>Allows customizing how a key is lifted before being passed to <a href="#StructUtils.addkeyval!"><code>addkeyval!</code></a> in <code>dictlike</code> construction.</p><p>By default, calls <a href="#StructUtils.lift"><code>StructUtils.lift</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">struct Point
    x::Int; y::Int
end

# lift a Point from a string value
StructUtils.liftkey(::StructUtils.StructStyle, x::String) = Point(parse(Int, split(x, &quot;_&quot;)[1]), parse(Int, split(x, &quot;_&quot;)[2]))

d = Dict(&quot;1_2&quot; =&gt; 99)
StructUtils.make(Dict{Point, Int}, Dict(&quot;1_2&quot; =&gt; 99))
# Dict{Point, Int} with 1 entry:
#   Point(1, 2) =&gt; 99</code></pre><p>For loss-less round-tripping also provide a <a href="#StructUtils.lowerkey-Tuple{StructUtils.StructStyle, Any}"><code>StructUtils.lowerkey</code></a> overload to &quot;lower&quot; the key.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L391-L417">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.lower"><a class="docstring-binding" href="#StructUtils.lower"><code>StructUtils.lower</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.lower(x) -&gt; x
StructUtils.lower(::StructStyle, x) -&gt; x</code></pre><p>Domain value transformation function. This function is called by <code>StructUtils.applyeach</code> on each value in the <code>source</code> object before calling the apply function. By default, <code>lower</code> is the identity function. This allows a domain transformation of values according to the style used.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L273-L282">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.lowerkey-Tuple{StructUtils.StructStyle, Any}"><a class="docstring-binding" href="#StructUtils.lowerkey-Tuple{StructUtils.StructStyle, Any}"><code>StructUtils.lowerkey</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">StructUtils.lowerkey(x) -&gt; x
StructUtils.lowerkey(style::StructUtils.StructStyle, x) -&gt; x</code></pre><p>Allows customizing how a value is lowered when used specifically as a key. By default, calls <a href="#StructUtils.lower"><code>StructUtils.lower</code></a>. Called from <a href="#StructUtils.applyeach"><code>StructUtils.applyeach</code></a> on the key or index before passed to the key-value function.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">struct Point
    x::Int; y::Int
end

# lower a Point as a single string value
StructUtils.lowerkey(::StructUtils.StructStyle, p::Point) = &quot;$(p.x)_$(p.y)&quot;

d = Dict(Point(1, 2) =&gt; 99)

StructUtils.make(Dict{String, Dict{String, Point}}, Dict(Point(1, 2) =&gt; Dict(Point(3, 4) =&gt; Point(5, 6))))
# Dict{String, Dict{String, Point}} with 1 entry:
#   &quot;1_2&quot; =&gt; Dict(&quot;3_4&quot;=&gt;Point(5, 6))</code></pre><p>For loss-less round-tripping also provide a <a href="#StructUtils.liftkey"><code>StructUtils.liftkey</code></a> overload to &quot;lift&quot; the key back.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L299-L325">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.make"><a class="docstring-binding" href="#StructUtils.make"><code>StructUtils.make</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.make(T, source) -&gt; T
StructUtils.make(T, source, style) -&gt; T
StructUtils.make(style, T, source) -&gt; Tuple{T, Any}
StructUtils.make!(style, x::T, source)</code></pre><p>Construct a struct of type <code>T</code> from <code>source</code> using the given <code>style</code>. The <code>source</code> can be any type of object, and the <code>style</code> can be any <code>StructStyle</code> subtype (default <code>StructUtils.DefaultStyle()</code>).</p><p><code>make</code> will use any knowledge of <code>noarg</code>, <code>arraylike</code>, or <code>dictlike</code> in order to determine how to construct an instance of <code>T</code>. The fallback for structs is to rely on the automatic &quot;all argument&quot; constructor that structs have defined by default (e.g. <code>T(fields...)</code>).</p><p><code>make</code> calls <code>applyeach</code> on the <code>source</code> object, where the key-value pairs from <code>source</code> will be used in constructing <code>T</code>.</p><p>The 3rd definition takes a <code>style</code> argument, allowing for overloads of non-owned types <code>T</code>. The main difference between this and the 2nd definition is that the 3rd definition allows for the <code>make</code> function to return a tuple of the constructed struct and any side-effect state derived from making the struct.</p><p>The 4th definition allows passing in an already-constructed instance of <code>T</code> (<code>x</code>), which must be mutable, and source key-value pairs will be applied as to <code>x</code> as source keys are matched to struct field names.</p><p>For structs, <code>fieldtags</code> will be accounted for and certain tags can be used to influence the construction of the struct.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L698-L725">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.make!"><a class="docstring-binding" href="#StructUtils.make!"><code>StructUtils.make!</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.make(T, source) -&gt; T
StructUtils.make(T, source, style) -&gt; T
StructUtils.make(style, T, source) -&gt; Tuple{T, Any}
StructUtils.make!(style, x::T, source)</code></pre><p>Construct a struct of type <code>T</code> from <code>source</code> using the given <code>style</code>. The <code>source</code> can be any type of object, and the <code>style</code> can be any <code>StructStyle</code> subtype (default <code>StructUtils.DefaultStyle()</code>).</p><p><code>make</code> will use any knowledge of <code>noarg</code>, <code>arraylike</code>, or <code>dictlike</code> in order to determine how to construct an instance of <code>T</code>. The fallback for structs is to rely on the automatic &quot;all argument&quot; constructor that structs have defined by default (e.g. <code>T(fields...)</code>).</p><p><code>make</code> calls <code>applyeach</code> on the <code>source</code> object, where the key-value pairs from <code>source</code> will be used in constructing <code>T</code>.</p><p>The 3rd definition takes a <code>style</code> argument, allowing for overloads of non-owned types <code>T</code>. The main difference between this and the 2nd definition is that the 3rd definition allows for the <code>make</code> function to return a tuple of the constructed struct and any side-effect state derived from making the struct.</p><p>The 4th definition allows passing in an already-constructed instance of <code>T</code> (<code>x</code>), which must be mutable, and source key-value pairs will be applied as to <code>x</code> as source keys are matched to struct field names.</p><p>For structs, <code>fieldtags</code> will be accounted for and certain tags can be used to influence the construction of the struct.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L698-L725">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.noarg"><a class="docstring-binding" href="#StructUtils.noarg"><code>StructUtils.noarg</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.noarg(x) -&gt; Bool
StructUtils.noarg(::StructStyle, x) -&gt; Bool
StructUtils.noarg(::StructStyle, ::Type{T}) -&gt; Bool</code></pre><p>Signals that <code>x</code> or type <code>T</code> is a mutable type that can be constructed by calling an empty constructor, like <code>t = T()</code>. Automatically overloaded when structs use the <code>@noarg</code> macro in their struct definition. The default value is <code>false</code> unless explicitly overloaded.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L45-L54">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.nulllike"><a class="docstring-binding" href="#StructUtils.nulllike"><code>StructUtils.nulllike</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.nulllike(x) -&gt; Bool
StructUtils.nulllike(::StructStyle, x) -&gt; Bool
StructUtils.nulllike(::StructStyle, ::Type{T}) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>x</code> or type <code>T</code> is null-like, <code>false</code> otherwise. This function is mainly used in the <code>make!</code> implementation to determine if a <code>Union</code> type can be narrowed by excluding <code>nulllike</code> types like <code>Nothing</code> and <code>Missing</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L258-L266">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.reset!-Tuple{T} where T"><a class="docstring-binding" href="#StructUtils.reset!-Tuple{T} where T"><code>StructUtils.reset!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">StructUtils.reset!(x::T)</code></pre><p>If <code>T</code> was defined with default values via <code>@defaults</code>, <code>@tags</code>, <code>@kwarg</code>, or <code>@noarg</code>, <code>reset!</code> will reset the fields of <code>x</code> to their default values. <code>T</code> must be a mutable struct type.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L1016-L1022">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.structlike"><a class="docstring-binding" href="#StructUtils.structlike"><code>StructUtils.structlike</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">StructUtils.structlike(x) -&gt; Bool
StructUtils.structlike(::StructStyle, x) -&gt; Bool
StructUtils.structlike(::StructStyle, ::Type{T}) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>x</code> or type <code>T</code> is struct-like, <code>false</code> otherwise. This function is called by <code>StructUtils.make</code> to determine if <code>T</code> is struct-like. The default implementation returns <code>true</code> for <code>isstructtype(T)</code> and <code>!Base.issingletontype(T)</code>.</p><p><code>structlike</code> structs are expected to be able to be constructed by the default constructor like <code>T(field1, field2, ...)</code>.</p><p>Due to how <code>StructUtils.make</code> works, <code>structlike</code> is often overloaded to <code>false</code> by &quot;unit&quot;/&quot;atom&quot; types where fields should be considered private to the <code>make</code> process and should instead attempt to <code>lift</code> the <code>source</code> object into the <code>unit</code> type.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L220-L235">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.@choosetype-Tuple{Any, Any}"><a class="docstring-binding" href="#StructUtils.@choosetype-Tuple{Any, Any}"><code>StructUtils.@choosetype</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">StructUtils.@choosetype T func
StructUtils.@choosetype style T func</code></pre><p>Convenience macro for defining a <code>StructUtils.make!</code> overload for an abstract type <code>T</code> where <code>func</code> is a function that &quot;chooses&quot; a concrete type <code>S</code> at runtime. <code>func</code> can be one of two forms:</p><ul><li><code>source -&gt; S</code></li><li><code>(source, tags) -&gt; S)</code></li></ul><p>That is, it either takes just the <code>source</code> object that is passed to <code>make</code> and must choose a concrete type <code>S</code>, or it can take both the <code>source</code> and a set of fieldtags that may be present for the field of a type being &quot;made&quot;.</p><p>The 2nd definition also takes a <code>style</code> argument, allowing for overloads of non-owned types <code>T</code>.</p><p>Example:</p><pre><code class="language-julia hljs">abstract type Vehicle end

struct Car &lt;: Vehicle
    make::String
    model::String
    seatingCapacity::Int
    topSpeed::Float64
end

struct Truck &lt;: Vehicle
    make::String
    model::String
    payloadCapacity::Float64
end

StructUtils.@choosetype Vehicle x -&gt; x[&quot;type&quot;] == &quot;car&quot; ? Car : x[&quot;type&quot;] == &quot;truck&quot; ? Truck : throw(ArgumentError(&quot;Unknown vehicle type: $(x[&quot;type&quot;])&quot;))

x = StructUtils.make(Vehicle, Dict(&quot;type&quot; =&gt; &quot;car&quot;, &quot;make&quot; =&gt; &quot;Toyota&quot;, &quot;model&quot; =&gt; &quot;Corolla&quot;, &quot;seatingCapacity&quot; =&gt; 4, &quot;topSpeed&quot; =&gt; 120.5))
@test x == Car(&quot;Toyota&quot;, &quot;Corolla&quot;, 4, 120.5)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/StructUtils.jl#L1053-L1091">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.@defaults-Tuple{Any}"><a class="docstring-binding" href="#StructUtils.@defaults-Tuple{Any}"><code>StructUtils.@defaults</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@defaults struct T
    ...
end</code></pre><p>Macro to enhance a <code>struct</code> definition by automatically generating an outer constructor with default values for trailing fields. The generated constructor will accept arguments for non-default fields and pass default values to the inner constructor. <code>StructUtils.fielddefaults</code> trait is also overridden to return a <code>NamedTuple</code> of default values for the struct type.</p><p>The <code>@noarg</code>, <code>@kwarg</code>, <code>@defaults</code>, and <code>@tags</code> macros all support specifying &quot;field tags&quot; for each field in a struct. Field tags are a NamedTuple prefixed by <code>&amp;</code> and are a way to attach metadata to a field. The field tags are accessible via the <code>StructUtils.fieldtags</code> function, and certain field tags are used by the <code>StructUtils.make</code> function to control how fields are constructed, including:</p><ul><li><code>dateformat</code>: a <code>DateFormat</code> object to use when parsing or formatting a <code>Dates.TimeType</code> field</li><li><code>lower</code>: a function to apply to a field when <code>applyeach</code> is called on a struct</li><li><code>lift</code>: a function to apply to a field when <code>StructUtils.make</code> is called on a struct</li><li><code>ignore</code>: a <code>Bool</code> to indicate if a field should be skipped/ignored when <code>applyeach</code> or <code>make</code> is called</li><li><code>name</code>: a <code>Symbol</code> to be used instead of a defined field name in <code>applyeach</code> or used to match a field in <code>make</code></li><li><code>choosetype</code>: a function to apply to a field when <code>StructUtils.make</code> is called to determine the concrete type of an abstract or Union typed field</li></ul><p>For example, the following struct definition includes a field with a <code>dateformat</code> tag:</p><pre><code class="language-julia hljs">@tags struct MyStruct
    date::Date &amp;(dateformat=dateformat&quot;yyyy-mm-dd&quot;,)
end</code></pre><p>Example</p><pre><code class="language-julia hljs">@defaults struct Foo
    a::Int
    b::String = &quot;foo&quot;
    c::Float64 = 1.0
    d::Vector{Int} = [1, 2, 3]
end</code></pre><p>In the above example, the <code>@defaults</code> macro generates the following outer constructor:</p><pre><code class="language-julia hljs">function Foo(a)
    return Foo(a, &quot;foo&quot;, 1.0, [1, 2, 3])
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/macros.jl#L362-L391">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.@kwarg-Tuple{Any}"><a class="docstring-binding" href="#StructUtils.@kwarg-Tuple{Any}"><code>StructUtils.@kwarg</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@kwarg struct T
    ...
end</code></pre><p>Macro to enhance a <code>struct</code> definition by automatically generating a keyword argument constructor. Default values can be specified for fields, which will be set in the generated constructor. <code>StructUtils.kwarg</code> trait is also overridden to return <code>true</code> for the struct type. This allows structs to easily participate in programmatic construction via <code>StructUtils.make</code>.</p><p>The <code>@noarg</code>, <code>@kwarg</code>, <code>@defaults</code>, and <code>@tags</code> macros all support specifying &quot;field tags&quot; for each field in a struct. Field tags are a NamedTuple prefixed by <code>&amp;</code> and are a way to attach metadata to a field. The field tags are accessible via the <code>StructUtils.fieldtags</code> function, and certain field tags are used by the <code>StructUtils.make</code> function to control how fields are constructed, including:</p><ul><li><code>dateformat</code>: a <code>DateFormat</code> object to use when parsing or formatting a <code>Dates.TimeType</code> field</li><li><code>lower</code>: a function to apply to a field when <code>applyeach</code> is called on a struct</li><li><code>lift</code>: a function to apply to a field when <code>StructUtils.make</code> is called on a struct</li><li><code>ignore</code>: a <code>Bool</code> to indicate if a field should be skipped/ignored when <code>applyeach</code> or <code>make</code> is called</li><li><code>name</code>: a <code>Symbol</code> to be used instead of a defined field name in <code>applyeach</code> or used to match a field in <code>make</code></li><li><code>choosetype</code>: a function to apply to a field when <code>StructUtils.make</code> is called to determine the concrete type of an abstract or Union typed field</li></ul><p>For example, the following struct definition includes a field with a <code>dateformat</code> tag:</p><pre><code class="language-julia hljs">@tags struct MyStruct
    date::Date &amp;(dateformat=dateformat&quot;yyyy-mm-dd&quot;,)
end</code></pre><p>Example</p><pre><code class="language-julia hljs">@kwarg struct Foo
    a::Int
    b::String = &quot;foo&quot;
    c::Float64 = 1.0
    d::Vector{Int} = [1, 2, 3]
end</code></pre><p>In the above example, the <code>@kwarg</code> macro generates the following inner constructor:</p><pre><code class="language-julia hljs">function Foo(; a, b=&quot;foo&quot;, c=1.0, d=[1, 2, 3])
    return Foo(a, b, c, d)
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/macros.jl#L328-L357">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.@noarg-Tuple{Any}"><a class="docstring-binding" href="#StructUtils.@noarg-Tuple{Any}"><code>StructUtils.@noarg</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@noarg mutable struct T
    ...
end</code></pre><p>Macro to enhance a <code>mutable struct</code> definition by automatically generating an empty or &quot;no-argument&quot; constructor. Similar to the <code>@kwarg</code> macro, default values can be specified for fields, which will be set in the generated constructor. <code>StructUtils.noarg</code> trait is also overridden to return <code>true</code> for the struct type. This allows structs to easily participate in programmatic construction via <code>StructUtils.make</code>.</p><p>Note that <code>const</code> fields are currently not allowed in <code>@noarg</code> structs.</p><p>The <code>@noarg</code>, <code>@kwarg</code>, <code>@defaults</code>, and <code>@tags</code> macros all support specifying &quot;field tags&quot; for each field in a struct. Field tags are a NamedTuple prefixed by <code>&amp;</code> and are a way to attach metadata to a field. The field tags are accessible via the <code>StructUtils.fieldtags</code> function, and certain field tags are used by the <code>StructUtils.make</code> function to control how fields are constructed, including:</p><ul><li><code>dateformat</code>: a <code>DateFormat</code> object to use when parsing or formatting a <code>Dates.TimeType</code> field</li><li><code>lower</code>: a function to apply to a field when <code>applyeach</code> is called on a struct</li><li><code>lift</code>: a function to apply to a field when <code>StructUtils.make</code> is called on a struct</li><li><code>ignore</code>: a <code>Bool</code> to indicate if a field should be skipped/ignored when <code>applyeach</code> or <code>make</code> is called</li><li><code>name</code>: a <code>Symbol</code> to be used instead of a defined field name in <code>applyeach</code> or used to match a field in <code>make</code></li><li><code>choosetype</code>: a function to apply to a field when <code>StructUtils.make</code> is called to determine the concrete type of an abstract or Union typed field</li></ul><p>For example, the following struct definition includes a field with a <code>dateformat</code> tag:</p><pre><code class="language-julia hljs">@tags struct MyStruct
    date::Date &amp;(dateformat=dateformat&quot;yyyy-mm-dd&quot;,)
end</code></pre><p>Example</p><pre><code class="language-julia hljs">@noarg mutable struct Foo
    a::Int
    b::String
    c::Float64 = 1.0
    d::Vector{Int} = [1, 2, 3]
end</code></pre><p>In the above example, the <code>@noarg</code> macro generates the following inner constructor:</p><pre><code class="language-julia hljs">function Foo()
    x = new()
    x.c = 1.0
    x.d = [1, 2, 3]
    return x
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/macros.jl#L287-L323">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.@nonstruct-Tuple{Any}"><a class="docstring-binding" href="#StructUtils.@nonstruct-Tuple{Any}"><code>StructUtils.@nonstruct</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@nonstruct struct T
    ...
end</code></pre><p>Macro to mark a struct as not struct-like for StructUtils purposes. This macro overrides <code>StructUtils.structlike</code> to return <code>false</code> for the struct type, which means that <code>StructUtils.make</code> will not attempt to construct the struct using its fields, but will instead use the <code>lift</code> function to convert the source directly to the struct type.</p><p>This is useful for &quot;unit&quot; or &quot;atom&quot; types where the fields should be considered private to the <code>make</code> process and the struct should be constructed by lifting the source object directly.</p><p><strong>Note</strong>: The <code>@nonstruct</code> macro does not support field defaults, field tags, or other StructUtils macros (<code>@defaults</code>, <code>@tags</code>, <code>@noarg</code>, <code>@kwarg</code>) because by using <code>@nonstruct</code>, you are explicitly opting out of StructUtils&#39; struct-like functionality. The struct&#39;s fields are considered private implementation details for the <code>make</code> process.</p><p>Example</p><pre><code class="language-julia hljs">@nonstruct struct MyUnit
    value::String
end

# This will use StructUtils.lift to convert the source directly to MyUnit
# rather than trying to construct it from field values
x = StructUtils.make(MyUnit, &quot;hello&quot;)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/macros.jl#L410-L441">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.@tags-Tuple{Any}"><a class="docstring-binding" href="#StructUtils.@tags-Tuple{Any}"><code>StructUtils.@tags</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@tags struct T
    ...
end</code></pre><p>Macro to enhance a <code>struct</code> definition by allowing field tags to be specified for each field.</p><p>The <code>@noarg</code>, <code>@kwarg</code>, <code>@defaults</code>, and <code>@tags</code> macros all support specifying &quot;field tags&quot; for each field in a struct. Field tags are a NamedTuple prefixed by <code>&amp;</code> and are a way to attach metadata to a field. The field tags are accessible via the <code>StructUtils.fieldtags</code> function, and certain field tags are used by the <code>StructUtils.make</code> function to control how fields are constructed, including:</p><ul><li><code>dateformat</code>: a <code>DateFormat</code> object to use when parsing or formatting a <code>Dates.TimeType</code> field</li><li><code>lower</code>: a function to apply to a field when <code>applyeach</code> is called on a struct</li><li><code>lift</code>: a function to apply to a field when <code>StructUtils.make</code> is called on a struct</li><li><code>ignore</code>: a <code>Bool</code> to indicate if a field should be skipped/ignored when <code>applyeach</code> or <code>make</code> is called</li><li><code>name</code>: a <code>Symbol</code> to be used instead of a defined field name in <code>applyeach</code> or used to match a field in <code>make</code></li><li><code>choosetype</code>: a function to apply to a field when <code>StructUtils.make</code> is called to determine the concrete type of an abstract or Union typed field</li></ul><p>For example, the following struct definition includes a field with a <code>dateformat</code> tag:</p><pre><code class="language-julia hljs">@tags struct MyStruct
    date::Date &amp;(dateformat=dateformat&quot;yyyy-mm-dd&quot;,)
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/macros.jl#L396-L405">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.Selectors"><a class="docstring-binding" href="#StructUtils.Selectors"><code>StructUtils.Selectors</code></a> — <span class="docstring-category">Module</span></summary><div><pre><code class="language-julia hljs">Selection syntax</code></pre><p>Special &quot;selection syntax&quot; is provided that allows easy querying of objects/arrays that implement <code>StructUtils.applyeach</code> using a syntax similar to XPath or CSS selectors, applied using common Julia syntax.</p><p>This syntax mainly uses various forms of <code>getindex</code> to select elements of an object or array. Supported syntax includes:</p><ul><li><code>x[&quot;key&quot;]</code> / <code>x.key</code> / <code>x[:key]</code> / <code>x[1]</code> - select the value associated for a key in object <code>x</code> (key can be a String, Symbol, or Integer for an array)</li><li><code>x[:]</code> - select all values in object or array <code>x</code>, returned as a <code>Selectors.List</code>, which is a custom array type that supports the selection syntax</li><li><code>x.key</code> - when <code>x</code> is a <code>List</code>, select the value for <code>key</code> in each element of the <code>List</code> (like a broadcasted <code>getindex</code>)</li><li><code>x[~, key]</code> - recursively select all values in object or array <code>x</code> that have <code>key</code></li><li><code>x[~, :]</code> - recursively select all values in object or array <code>x</code>, returned as a flattened <code>List</code></li><li><code>x[:, (k, v) -&gt; Bool]</code> - apply a key-value function <code>f</code> to each key-value/index-value in object or array <code>x</code>, and return a <code>List</code> of all values for which <code>f</code> returns <code>true</code></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/selectors.jl#L1-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StructUtils.Selectors.List"><a class="docstring-binding" href="#StructUtils.Selectors.List"><code>StructUtils.Selectors.List</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">List(...)</code></pre><p>A custom array wrapper that supports the Selectors selection syntax.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaServices/StructUtils.jl/blob/a8e93895a10e2f67fae1c24c5122c261e09f8588/src/selectors.jl#L22-L26">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« StructUtils.jl Documentation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Sunday 16 November 2025 06:18">Sunday 16 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
