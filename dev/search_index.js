var documenterSearchIndex = {"docs":
[{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"reference/#StructUtils.DefaultStyle","page":"API Reference","title":"StructUtils.DefaultStyle","text":"StructUtils.DefaultStyle\n\nDefault struct style that all StructUtils.jl interface methods are defined for by default.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructUtils.EarlyReturn","page":"API Reference","title":"StructUtils.EarlyReturn","text":"StructUtils.EarlyReturn{T}\n\nA wrapper type that can be used in function arguments to applyeach to short-circuit iteration and return a value from applyeach.\n\nExample usage:\n\njulia function find_needle_in_haystack(haystack, needle)     ret = applyeach(haystack) do k, v         k == needle && return StructUtils.EarlyReturn(v)     end     ret isa StructUtils.EarlyReturn && return ret.value     throw(ArgumentError(\"needle not found in haystack\") end`\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructUtils.StructStyle","page":"API Reference","title":"StructUtils.StructStyle","text":"StructUtils.StructStyle\n\nAbstract type that all concrete struct styles must subtype. Custom struct styles allow fine-grained control over various StructUtils.jl interface methods like fieldtags, fielddefaults, lift, lower, etc.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructUtils.addkeyval!","page":"API Reference","title":"StructUtils.addkeyval!","text":"StructUtils.addkeyval!(d, k, v)\n\nAdd a key-value pair to a dictionary-like object d. This function is called by StructUtils.make when d is dictlike. The default implementation is to call d[k] = v for AbstractDict.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.applyeach","page":"API Reference","title":"StructUtils.applyeach","text":"StructUtils.applyeach(style, f, x) -> Union{StructUtils.EarlyReturn, Nothing}\n\nA custom foreach-like function that operates specifically on (key, val) or (ind, val) pairs, and supports short-circuiting (via StructUtils.EarlyReturn). It also supports a StructStyle argument to allow for style-specific behavior for non-owned types.\n\nFor each key-value or index-value pair in x, call f(k, v). If f returns a StructUtils.EarlyReturn instance, applyeach should return the EarlyReturn immediately and stop iterating (i.e. short-circuit). Otherwise, the return value of f can be ignored and iteration continues.\n\nKey types are generally expected to be Symbols, Strings, or Integers.\n\nAn example overload of applyeach for a generic iterable would be:\n\nfunction StructUtils.applyeach(style::StructUtils.StructStyle, f, x::MyIterable)\n    for (i, v) in enumerate(x)\n        ret = f(StructUtils.lowerkey(style, i), StructUtils.lower(style, v))\n        # if `f` returns EarlyReturn, return immediately\n        ret isa StructUtils.EarlyReturn && return ret\n    end\n    return\nend\n\nNote that applyeach must include the style argument when overloading.\n\nAlso note that before applying f, the key or index is passed through StructUtils.lowerkey(style, k), and the value v is passed through StructUtils.lower(style, v).\n\nIf a value is #undef or otherwise not defined, the f function should generally be called with nothing or skipped.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.arraylike","page":"API Reference","title":"StructUtils.arraylike","text":"StructUtils.arraylike(x) -> Bool   StructUtils.arraylike(::StructStyle, x) -> Bool   StructUtils.arraylike(::StructStyle, ::Type{T}) -> Bool\n\nReturns true if x or type T is array-like, false otherwise. This function is called by StructUtils.make to determine if T is array-like. The default implementation returns true for <:AbstractArray, <:AbstractSet, <:Tuple, <:Base.Generator, and <:Core.SimpleVector types, and false for <:AbstractArray{T,0}.\n\nOnce initialize is called, StructUtils.make will call push! to add values to the array-like object.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.defaultstate-Tuple{StructUtils.StructStyle}","page":"API Reference","title":"StructUtils.defaultstate","text":"StructUtils.defaultstate(::StructStyle) -> Any\n\nReturns the default state for a given struct style. This is used to initialize the state of a struct when no state is provided. The default implementation returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#StructUtils.dictlike","page":"API Reference","title":"StructUtils.dictlike","text":"StructUtils.dictlike(x) -> Bool   StructUtils.dictlike(::StructStyle, x) -> Bool   StructUtils.dictlike(::StructStyle, ::Type{T}) -> Bool\n\nReturns true if x or type T is dictionary-like, false otherwise. When StructUtils.make(T, source) is called, if dictlike(T) is true, an instance will be initialized, and then addkeyval!ed for each key-value pair in source.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.fielddefault","page":"API Reference","title":"StructUtils.fielddefault","text":"StructUtils.fielddefaults(::StructStyle, ::Type{T}) -> NamedTuple\nStructUtils.fielddefault(::StructStyle, ::Type{T}, fieldname) -> NamedTuple\n\nReturns a NamedTuple of field defaults for the struct T. Field defaults can be added manually by overloading fielddefaults, or included via convenient syntax using the StructUtils.jl macros: @tags, @noarg, @defaults, or @kwarg.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.fielddefaults","page":"API Reference","title":"StructUtils.fielddefaults","text":"StructUtils.fielddefaults(::StructStyle, ::Type{T}) -> NamedTuple\nStructUtils.fielddefault(::StructStyle, ::Type{T}, fieldname) -> NamedTuple\n\nReturns a NamedTuple of field defaults for the struct T. Field defaults can be added manually by overloading fielddefaults, or included via convenient syntax using the StructUtils.jl macros: @tags, @noarg, @defaults, or @kwarg.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.fieldtagkey","page":"API Reference","title":"StructUtils.fieldtagkey","text":"StructUtils.fieldtagkey(::StructStyle) -> Symbol\n\nField tags defined on struct fields can be grouped by keys that are associated with a particular struct style. This function returns the key that should be used to retrieve field tags for a given struct style. By default, this function returns nothing. An example overload might look like:\n\nstruct MySQLStyle <: StructStyle end\n\nStructUtils.fieldtagkey(::MySQLStyle) = :mysql\n\n@tags struct Foo\n    a::Int &(mysql=(name=\"foo_a\",),)\n    b::String\nend\n\nIn this example, when StructUtils.make is called on Foo with the MySQLStyle style, only (name=\"foo_a\",) will be retrieved from the field tags for a because the mysql key is associated with the MySQLStyle struct style. In other words, fieldtag keys allow custom struct styles to \"namespace\" field tags so structs can overload specific tags in multiple ways for different namespaces, i.e. a::Int &(mysql=(name=\"foo_a\",), json=(name=\"json_a\",)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.fieldtags","page":"API Reference","title":"StructUtils.fieldtags","text":"StructUtils.fieldtags(::StructStyle, ::Type{T}) -> NamedTuple\nStructUtils.fieldtags(::StructStyle, ::Type{T}, fieldname) -> NamedTuple\n\nReturns a NamedTuple of field tags for the struct T. Field tags can be added manually by overloading fieldtags, or included via convenient syntax using the StructUtils.jl macros: @tags, @noarg, @defaults, or @kwarg. Note this function returns the tags of all fields as a single NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.initialize","page":"API Reference","title":"StructUtils.initialize","text":"StructUtils.initialize(::StructStyle, T, source) -> T\n\nIn StructUtils.make, this function is called to initialize a new instance of T, when T is dictlike, arraylike, or noarg. The source is passed from the call to make, and can be used for initialization if appropriate. The default implementation of initialize is to call T() or T(undef, 0) for <:AbstractArray types.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.kwarg","page":"API Reference","title":"StructUtils.kwarg","text":"StructUtils.kwarg(x) -> Bool   StructUtils.kwarg(::StructStyle, x) -> Bool   StructUtils.kwarg(::StructStyle, ::Type{T}) -> Bool\n\nSignals that x or type T can be constructed by passing struct fields as keyword arguments to the constructor, like t = T(field1=a, field2=b, ...). Automatically overloaded when structs use the StructUtils.@kwarg macro in their struct definition. The default value is false unless explicitly overloaded.\n\nNote that StructUtils.@kwarg is a separate implementation of Base.@kwdef, yet should be a drop-in replacement for it.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.lift","page":"API Reference","title":"StructUtils.lift","text":"StructUtils.lift(::Type{T}, x) -> T   StructUtils.lift(::StructStyle, ::Type{T}, x) -> Tuple{T, Any}\n\nLifts a value x to a type T. This function is called by StructUtils.make to lift unit/atom values to the appropriate type. The default implementation is the identity function for most types, but it also includes special cases for Symbol, Char, UUID, VersionNumber, Regex, and TimeType types to be constructed from strings. Allows transforming a \"domain value\" that may be some primitive representation into a more complex Julia type.\n\nThe method with a StructStyle argument should return a tuple of the lifted value and any side-effect state derived from lifting the value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.liftkey","page":"API Reference","title":"StructUtils.liftkey","text":"StructUtils.liftkey(::Type{T}, x) -> x   StructUtils.liftkey(style::StructStyle, ::Type{T}, x) -> x\n\nAllows customizing how a key is lifted before being passed to addkeyval! in dictlike construction.\n\nBy default, calls StructUtils.lift.\n\nExample\n\nstruct Point\n    x::Int; y::Int\nend\n\n# lift a Point from a string value\nStructUtils.liftkey(::StructUtils.StructStyle, x::String) = Point(parse(Int, split(x, \"_\")[1]), parse(Int, split(x, \"_\")[2]))\n\nd = Dict(\"1_2\" => 99)\nStructUtils.make(Dict{Point, Int}, Dict(\"1_2\" => 99))\n# Dict{Point, Int} with 1 entry:\n#   Point(1, 2) => 99\n\nFor loss-less round-tripping also provide a StructUtils.lowerkey overload to \"lower\" the key.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.lower","page":"API Reference","title":"StructUtils.lower","text":"StructUtils.lower(x) -> x   StructUtils.lower(::StructStyle, x) -> x\n\nDomain value transformation function. This function is called by StructUtils.applyeach on each value in the source object before calling the apply function. By default, lower is the identity function. This allows a domain transformation of values according to the style used.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.lowerkey-Tuple{StructUtils.StructStyle, Any}","page":"API Reference","title":"StructUtils.lowerkey","text":"StructUtils.lowerkey(x) -> x   StructUtils.lowerkey(style::StructUtils.StructStyle, x) -> x\n\nAllows customizing how a value is lowered when used specifically as a key. By default, calls StructUtils.lower. Called from StructUtils.applyeach on the key or index before passed to the key-value function.\n\nExample\n\nstruct Point\n    x::Int; y::Int\nend\n\n# lower a Point as a single string value\nStructUtils.lowerkey(::StructUtils.StructStyle, p::Point) = \"$(p.x)_$(p.y)\"\n\nd = Dict(Point(1, 2) => 99)\n\nStructUtils.make(Dict{String, Dict{String, Point}}, Dict(Point(1, 2) => Dict(Point(3, 4) => Point(5, 6))))\n# Dict{String, Dict{String, Point}} with 1 entry:\n#   \"1_2\" => Dict(\"3_4\"=>Point(5, 6))\n\nFor loss-less round-tripping also provide a StructUtils.liftkey overload to \"lift\" the key back.\n\n\n\n\n\n","category":"method"},{"location":"reference/#StructUtils.make","page":"API Reference","title":"StructUtils.make","text":"StructUtils.make(T, source) -> T\nStructUtils.make(T, source, style) -> T\nStructUtils.make(style, T, source) -> Tuple{T, Any}\nStructUtils.make!(style, x::T, source)\n\nConstruct a struct of type T from source using the given style. The source can be any type of object, and the style can be any StructStyle subtype (default StructUtils.DefaultStyle()).\n\nmake will use any knowledge of noarg, arraylike, or dictlike in order to determine how to construct an instance of T. The fallback for structs is to rely on the automatic \"all argument\" constructor that structs have defined by default (e.g. T(fields...)).\n\nmake calls applyeach on the source object, where the key-value pairs from source will be used in constructing T.\n\nThe 3rd definition takes a style argument, allowing for overloads of non-owned types T. The main difference between this and the 2nd definition is that the 3rd definition allows for the make function to return a tuple of the constructed struct and any side-effect state derived from making the struct.\n\nThe 4th definition allows passing in an already-constructed instance of T (x), which must be mutable, and source key-value pairs will be applied as to x as source keys are matched to struct field names.\n\nFor structs, fieldtags will be accounted for and certain tags can be used to influence the construction of the struct.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.make!","page":"API Reference","title":"StructUtils.make!","text":"StructUtils.make(T, source) -> T\nStructUtils.make(T, source, style) -> T\nStructUtils.make(style, T, source) -> Tuple{T, Any}\nStructUtils.make!(style, x::T, source)\n\nConstruct a struct of type T from source using the given style. The source can be any type of object, and the style can be any StructStyle subtype (default StructUtils.DefaultStyle()).\n\nmake will use any knowledge of noarg, arraylike, or dictlike in order to determine how to construct an instance of T. The fallback for structs is to rely on the automatic \"all argument\" constructor that structs have defined by default (e.g. T(fields...)).\n\nmake calls applyeach on the source object, where the key-value pairs from source will be used in constructing T.\n\nThe 3rd definition takes a style argument, allowing for overloads of non-owned types T. The main difference between this and the 2nd definition is that the 3rd definition allows for the make function to return a tuple of the constructed struct and any side-effect state derived from making the struct.\n\nThe 4th definition allows passing in an already-constructed instance of T (x), which must be mutable, and source key-value pairs will be applied as to x as source keys are matched to struct field names.\n\nFor structs, fieldtags will be accounted for and certain tags can be used to influence the construction of the struct.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.noarg","page":"API Reference","title":"StructUtils.noarg","text":"StructUtils.noarg(x) -> Bool   StructUtils.noarg(::StructStyle, x) -> Bool   StructUtils.noarg(::StructStyle, ::Type{T}) -> Bool\n\nSignals that x or type T is a mutable type that can be constructed by calling an empty constructor, like t = T(). Automatically overloaded when structs use the @noarg macro in their struct definition. The default value is false unless explicitly overloaded.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.nulllike","page":"API Reference","title":"StructUtils.nulllike","text":"StructUtils.nulllike(x) -> Bool   StructUtils.nulllike(::StructStyle, x) -> Bool   StructUtils.nulllike(::StructStyle, ::Type{T}) -> Bool\n\nReturns true if x or type T is null-like, false otherwise. This function is mainly used in the make! implementation to determine if a Union type can be narrowed by excluding nulllike types like Nothing and Missing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.reset!-Tuple{T} where T","page":"API Reference","title":"StructUtils.reset!","text":"StructUtils.reset!(x::T)\n\nIf T was defined with default values via @defaults, @tags, @kwarg, or @noarg, reset! will reset the fields of x to their default values. T must be a mutable struct type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#StructUtils.structlike","page":"API Reference","title":"StructUtils.structlike","text":"StructUtils.structlike(x) -> Bool   StructUtils.structlike(::StructStyle, x) -> Bool   StructUtils.structlike(::StructStyle, ::Type{T}) -> Bool\n\nReturns true if x or type T is struct-like, false otherwise. This function is called by StructUtils.make to determine if T is struct-like. The default implementation returns true for isstructtype(T) and !Base.issingletontype(T).\n\nstructlike structs are expected to be able to be constructed by the default constructor like T(field1, field2, ...).\n\nDue to how StructUtils.make works, structlike is often overloaded to false by \"unit\"/\"atom\" types where fields should be considered private to the make process and should instead attempt to lift the source object into the unit type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructUtils.@choosetype-Tuple{Any, Any}","page":"API Reference","title":"StructUtils.@choosetype","text":"StructUtils.@choosetype T func\nStructUtils.@choosetype style T func\n\nConvenience macro for defining a StructUtils.make! overload for an abstract type T where func is a function that \"chooses\" a concrete type S at runtime. func can be one of two forms:\n\nsource -> S\n(source, tags) -> S)\n\nThat is, it either takes just the source object that is passed to make and must choose a concrete type S, or it can take both the source and a set of fieldtags that may be present for the field of a type being \"made\".\n\nThe 2nd definition also takes a style argument, allowing for overloads of non-owned types T.\n\nExample:\n\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nStructUtils.@choosetype Vehicle x -> x[\"type\"] == \"car\" ? Car : x[\"type\"] == \"truck\" ? Truck : throw(ArgumentError(\"Unknown vehicle type: $(x[\"type\"])\"))\n\nx = StructUtils.make(Vehicle, Dict(\"type\" => \"car\", \"make\" => \"Toyota\", \"model\" => \"Corolla\", \"seatingCapacity\" => 4, \"topSpeed\" => 120.5))\n@test x == Car(\"Toyota\", \"Corolla\", 4, 120.5)\n\n\n\n\n\n","category":"macro"},{"location":"reference/#StructUtils.@defaults-Tuple{Any}","page":"API Reference","title":"StructUtils.@defaults","text":"@defaults struct T\n    ...\nend\n\nMacro to enhance a struct definition by automatically generating an outer constructor with default values for trailing fields. The generated constructor will accept arguments for non-default fields and pass default values to the inner constructor. StructUtils.fielddefaults trait is also overridden to return a NamedTuple of default values for the struct type.\n\nThe @noarg, @kwarg, @defaults, and @tags macros all support specifying \"field tags\" for each field in a struct. Field tags are a NamedTuple prefixed by & and are a way to attach metadata to a field. The field tags are accessible via the StructUtils.fieldtags function, and certain field tags are used by the StructUtils.make function to control how fields are constructed, including:\n\ndateformat: a DateFormat object to use when parsing or formatting a Dates.TimeType field\nlower: a function to apply to a field when applyeach is called on a struct\nlift: a function to apply to a field when StructUtils.make is called on a struct\nignore: a Bool to indicate if a field should be skipped/ignored when applyeach or make is called\nname: a Symbol to be used instead of a defined field name in applyeach or used to match a field in make\nchoosetype: a function to apply to a field when StructUtils.make is called to determine the concrete type of an abstract or Union typed field\n\nFor example, the following struct definition includes a field with a dateformat tag:\n\n@tags struct MyStruct\n    date::Date &(dateformat=dateformat\"yyyy-mm-dd\",)\nend\n\nExample\n\n@defaults struct Foo\n    a::Int\n    b::String = \"foo\"\n    c::Float64 = 1.0\n    d::Vector{Int} = [1, 2, 3]\nend\n\nIn the above example, the @defaults macro generates the following outer constructor:\n\nfunction Foo(a)\n    return Foo(a, \"foo\", 1.0, [1, 2, 3])\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#StructUtils.@kwarg-Tuple{Any}","page":"API Reference","title":"StructUtils.@kwarg","text":"@kwarg struct T\n    ...\nend\n\nMacro to enhance a struct definition by automatically generating a keyword argument constructor. Default values can be specified for fields, which will be set in the generated constructor. StructUtils.kwarg trait is also overridden to return true for the struct type. This allows structs to easily participate in programmatic construction via StructUtils.make.\n\nThe @noarg, @kwarg, @defaults, and @tags macros all support specifying \"field tags\" for each field in a struct. Field tags are a NamedTuple prefixed by & and are a way to attach metadata to a field. The field tags are accessible via the StructUtils.fieldtags function, and certain field tags are used by the StructUtils.make function to control how fields are constructed, including:\n\ndateformat: a DateFormat object to use when parsing or formatting a Dates.TimeType field\nlower: a function to apply to a field when applyeach is called on a struct\nlift: a function to apply to a field when StructUtils.make is called on a struct\nignore: a Bool to indicate if a field should be skipped/ignored when applyeach or make is called\nname: a Symbol to be used instead of a defined field name in applyeach or used to match a field in make\nchoosetype: a function to apply to a field when StructUtils.make is called to determine the concrete type of an abstract or Union typed field\n\nFor example, the following struct definition includes a field with a dateformat tag:\n\n@tags struct MyStruct\n    date::Date &(dateformat=dateformat\"yyyy-mm-dd\",)\nend\n\nExample\n\n@kwarg struct Foo\n    a::Int\n    b::String = \"foo\"\n    c::Float64 = 1.0\n    d::Vector{Int} = [1, 2, 3]\nend\n\nIn the above example, the @kwarg macro generates the following inner constructor:\n\nfunction Foo(; a, b=\"foo\", c=1.0, d=[1, 2, 3])\n    return Foo(a, b, c, d)\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#StructUtils.@noarg-Tuple{Any}","page":"API Reference","title":"StructUtils.@noarg","text":"@noarg mutable struct T\n    ...\nend\n\nMacro to enhance a mutable struct definition by automatically generating an empty or \"no-argument\" constructor. Similar to the @kwarg macro, default values can be specified for fields, which will be set in the generated constructor. StructUtils.noarg trait is also overridden to return true for the struct type. This allows structs to easily participate in programmatic construction via StructUtils.make.\n\nNote that const fields are currently not allowed in @noarg structs.\n\nThe @noarg, @kwarg, @defaults, and @tags macros all support specifying \"field tags\" for each field in a struct. Field tags are a NamedTuple prefixed by & and are a way to attach metadata to a field. The field tags are accessible via the StructUtils.fieldtags function, and certain field tags are used by the StructUtils.make function to control how fields are constructed, including:\n\ndateformat: a DateFormat object to use when parsing or formatting a Dates.TimeType field\nlower: a function to apply to a field when applyeach is called on a struct\nlift: a function to apply to a field when StructUtils.make is called on a struct\nignore: a Bool to indicate if a field should be skipped/ignored when applyeach or make is called\nname: a Symbol to be used instead of a defined field name in applyeach or used to match a field in make\nchoosetype: a function to apply to a field when StructUtils.make is called to determine the concrete type of an abstract or Union typed field\n\nFor example, the following struct definition includes a field with a dateformat tag:\n\n@tags struct MyStruct\n    date::Date &(dateformat=dateformat\"yyyy-mm-dd\",)\nend\n\nExample\n\n@noarg mutable struct Foo\n    a::Int\n    b::String\n    c::Float64 = 1.0\n    d::Vector{Int} = [1, 2, 3]\nend\n\nIn the above example, the @noarg macro generates the following inner constructor:\n\nfunction Foo()\n    x = new()\n    x.c = 1.0\n    x.d = [1, 2, 3]\n    return x\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#StructUtils.@nonstruct-Tuple{Any}","page":"API Reference","title":"StructUtils.@nonstruct","text":"@nonstruct struct T\n    ...\nend\n\nMacro to mark a struct as not struct-like for StructUtils purposes. This macro overrides StructUtils.structlike to return false for the struct type, which means that StructUtils.make will not attempt to construct the struct using its fields, but will instead use the lift function to convert the source directly to the struct type.\n\nThis is useful for \"unit\" or \"atom\" types where the fields should be considered private to the make process and the struct should be constructed by lifting the source object directly.\n\nNote: The @nonstruct macro does not support field defaults, field tags, or other StructUtils macros (@defaults, @tags, @noarg, @kwarg) because by using @nonstruct, you are explicitly opting out of StructUtils' struct-like functionality. The struct's fields are considered private implementation details for the make process.\n\nExample\n\n@nonstruct struct MyUnit\n    value::String\nend\n\n# This will use StructUtils.lift to convert the source directly to MyUnit\n# rather than trying to construct it from field values\nx = StructUtils.make(MyUnit, \"hello\")\n\n\n\n\n\n","category":"macro"},{"location":"reference/#StructUtils.@tags-Tuple{Any}","page":"API Reference","title":"StructUtils.@tags","text":"@tags struct T\n    ...\nend\n\nMacro to enhance a struct definition by allowing field tags to be specified for each field.\n\nThe @noarg, @kwarg, @defaults, and @tags macros all support specifying \"field tags\" for each field in a struct. Field tags are a NamedTuple prefixed by & and are a way to attach metadata to a field. The field tags are accessible via the StructUtils.fieldtags function, and certain field tags are used by the StructUtils.make function to control how fields are constructed, including:\n\ndateformat: a DateFormat object to use when parsing or formatting a Dates.TimeType field\nlower: a function to apply to a field when applyeach is called on a struct\nlift: a function to apply to a field when StructUtils.make is called on a struct\nignore: a Bool to indicate if a field should be skipped/ignored when applyeach or make is called\nname: a Symbol to be used instead of a defined field name in applyeach or used to match a field in make\nchoosetype: a function to apply to a field when StructUtils.make is called to determine the concrete type of an abstract or Union typed field\n\nFor example, the following struct definition includes a field with a dateformat tag:\n\n@tags struct MyStruct\n    date::Date &(dateformat=dateformat\"yyyy-mm-dd\",)\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#StructUtils.Selectors","page":"API Reference","title":"StructUtils.Selectors","text":"Selection syntax\n\nSpecial \"selection syntax\" is provided that allows easy querying of objects/arrays that implement StructUtils.applyeach using a syntax similar to XPath or CSS selectors, applied using common Julia syntax.\n\nThis syntax mainly uses various forms of getindex to select elements of an object or array. Supported syntax includes:\n\nx[\"key\"] / x.key / x[:key] / x[1] - select the value associated for a key in object x (key can be a String, Symbol, or Integer for an array)\nx[:] - select all values in object or array x, returned as a Selectors.List, which is a custom array type that supports the selection syntax\nx.key - when x is a List, select the value for key in each element of the List (like a broadcasted getindex)\nx[~, key] - recursively select all values in object or array x that have key\nx[~, :] - recursively select all values in object or array x, returned as a flattened List\nx[:, (k, v) -> Bool] - apply a key-value function f to each key-value/index-value in object or array x, and return a List of all values for which f returns true\n\n\n\n\n\n","category":"module"},{"location":"reference/#StructUtils.Selectors.List","page":"API Reference","title":"StructUtils.Selectors.List","text":"List(...)\n\nA custom array wrapper that supports the Selectors selection syntax.\n\n\n\n\n\n","category":"type"},{"location":"#StructUtils.jl-Documentation","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"StructUtils.jl provides flexible tools for working with Julia structs, making it easier to build, manipulate, and convert between different data structures. It offers macros for defining struct behaviors and a powerful make function for programmatic construction of objects from various data sources.","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Pages = [\"index.md\"]\nDepth = 3","category":"page"},{"location":"#Installation","page":"StructUtils.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The package is registered in the General registry and can be installed at the REPL with:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"] add StructUtils","category":"page"},{"location":"#Quick-Start","page":"StructUtils.jl Documentation","title":"Quick Start","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"StructUtils.jl offers several key features:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Struct definition macros - Enhance struct definitions with special behaviors:\nusing StructUtils\n\n# Define a struct with default values\n@defaults struct Config\n    port::Int = 8080\n    host::String = \"localhost\"\n    debug::Bool = false\nend\n\n# Only need to provide non-default values\nconfig = Config(9000)  # Config(9000, \"localhost\", false)\nProgrammatic object construction - Convert between different data representations:\n# Convert a Dict to our Config struct\ndict = Dict(:port => 9000, :host => \"example.com\")\nconfig = StructUtils.make(Config, dict)  # Config(9000, \"example.com\", false)\n\n# Convert a Config back to a Dict\ndict_again = StructUtils.make(Dict{Symbol,Any}, config)  # Dict(:port => 9000, :host => \"example.com\", :debug => false)","category":"page"},{"location":"#Core-Concepts","page":"StructUtils.jl Documentation","title":"Core Concepts","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"StructUtils.jl is built around several key concepts:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Struct Styles - Define customization points for handling different struct types\nField Tags - Add metadata to struct fields for controlling serialization and deserialization\nStruct Macros - Enhance struct definitions with special behaviors\nThe make function - Programmatically construct objects from various data sources","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Let's explore each of these concepts in detail.","category":"page"},{"location":"#Struct-Styles","page":"StructUtils.jl Documentation","title":"Struct Styles","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"At the core of StructUtils.jl is the concept of a StructStyle:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"abstract type StructStyle end\nstruct DefaultStyle <: StructStyle end","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Struct styles provide a way to customize how structs are handled. The DefaultStyle is used by default, but you can create custom styles to override behavior for specific types, especially those you don't own:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"struct MyCustomStyle <: StructStyle end\n\n# Override behavior for a type you don't own\nStructUtils.lift(::MyCustomStyle, ::Type{UUID}, x::AbstractString) = UUID(x)","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"This approach allows library authors to provide custom serialization/deserialization behavior for their types without modifying the original package.","category":"page"},{"location":"#Struct-Definition-Macros","page":"StructUtils.jl Documentation","title":"Struct Definition Macros","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"StructUtils.jl provides several macros to enhance struct definitions:","category":"page"},{"location":"#@nonstruct-Non-struct-like-Types","page":"StructUtils.jl Documentation","title":"@nonstruct - Non-struct-like Types","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The @nonstruct macro marks a struct as not struct-like for StructUtils purposes. This is useful for custom types that should be treated as primitives rather than structs during serialization/deserialization:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"@nonstruct struct Email\n    value::String\nend\n\n# Define conversion methods\nStructUtils.lift(::Type{Email}, x::String) = Email(x)\nStructUtils.lower(x::Email) = x.value\n\n# Now Email will be serialized as a string, not an object\nuser = User(email=Email(\"alice@example.com\"))\ndict = StructUtils.make(Dict{String,Any}, user)  # email field is a string","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Note: @nonstruct does not support field defaults, tags, or other StructUtils macros since you're explicitly opting out of struct-like behavior.","category":"page"},{"location":"#@noarg-No-argument-Constructor","page":"StructUtils.jl Documentation","title":"@noarg - No-argument Constructor","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The @noarg macro creates a no-argument constructor for mutable structs and allows setting default values:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"@noarg mutable struct User\n    id::Int\n    name::String\n    created_at::DateTime = now()\n    active::Bool = true\nend\n\n# Now you can create a User without arguments\nuser = User()  # Fields will be undefined except those with defaults\nuser.id = 1\nuser.name = \"Alice\"","category":"page"},{"location":"#@defaults-Default-Values","page":"StructUtils.jl Documentation","title":"@defaults - Default Values","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The @defaults macro creates an additional constructor that allows omitting arguments with default values:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"@defaults struct Point\n    x::Float64\n    y::Float64\n    z::Float64 = 0.0  # Default value\nend\n\n# You can omit the z argument\npoint = Point(1.0, 2.0)  # Point(1.0, 2.0, 0.0)","category":"page"},{"location":"#@kwarg-Keyword-Constructor","page":"StructUtils.jl Documentation","title":"@kwarg - Keyword Constructor","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Similar to Base Julia's @kwdef, but with enhanced capabilities:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"@kwarg struct HttpConfig\n    port::Int = 8080\n    host::String = \"localhost\"\n    timeout::Int = 30\nend\n\n# Create with keyword arguments\nconfig = HttpConfig(port=9000)  # HttpConfig(9000, \"localhost\", 30)","category":"page"},{"location":"#@tags-Field-Metadata","page":"StructUtils.jl Documentation","title":"@tags - Field Metadata","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The @tags macro allows attaching metadata to struct fields using the &(...) syntax:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"@tags struct Person\n    id::Int &(json=(name=\"person_id\",),)\n    first_name::String &(json=(name=\"firstName\",),)\n    birth_date::Date &(dateformat=\"yyyy-mm-dd\",)\n    internal_note::String &(json=(ignore=true,),)\nend","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Each field can have tags that control how it's handled by different libraries. For example:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"name - Use a different name when serializing/deserializing\ndateformat - Specify a format for date parsing/formatting\nignore - Skip this field during serialization/deserialization\nlift/lower - Custom functions to convert values during serialization/deserialization","category":"page"},{"location":"#Field-Tags-Syntax","page":"StructUtils.jl Documentation","title":"Field Tags Syntax","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Field tags use a special syntax: &(namespace=(key=value,),). The namespace (like json) allows different libraries to use their own tags without conflicts.","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Common field tags include:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"name: Alternative name to use when matching source keys\nignore: Skip this field during serialization/deserialization (boolean)\ndateformat: Format string or DateFormat object for date fields\nlift: Function to convert source values to field type\nlower: Function to convert field values to serialization format\nchoosetype: Function to determine concrete type for abstract fields","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Example of a field with multiple tags:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"@tags struct Document\n    id::Int &(json=(name=\"doc_id\",), db=(column=\"document_id\",))\n    created::DateTime &(json=(dateformat=\"yyyy-mm-dd\",), db=(column=\"creation_date\",))\n    data::Any &(json=(ignore=true,), db=(ignore=true,))\nend","category":"page"},{"location":"#The-make-Function","page":"StructUtils.jl Documentation","title":"The make Function","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The core functionality of StructUtils.jl is in the make function, which creates an object of a specific type from a source object:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"StructUtils.make(T, source) -> T\nStructUtils.make(T, source, style) -> T","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"This function can convert between many kinds of objects:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"# Convert a Dict to a struct\nuser = StructUtils.make(User, Dict(\"id\" => 1, \"name\" => \"Alice\"))\n\n# Convert a struct to a Dict\ndict = StructUtils.make(Dict{String,Any}, user)\n\n# Convert a struct to a NamedTuple\nnt = StructUtils.make(NamedTuple, user)\n\n# Convert a JSON object to a struct (with JSON.jl)\nuser = JSON.parse(json_string, User)  # Uses StructUtils.make under the hood","category":"page"},{"location":"#How-make-Works","page":"StructUtils.jl Documentation","title":"How make Works","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The make function follows these steps:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Type Analysis: Determine if the target type is:\nDictionary-like (AbstractDict, Vector{Pair})\nArray-like (AbstractArray, Tuple, Set)\nNo-arg constructible (@noarg or overridden noarg function)\nRegular struct (default constructor)\nPrimitive type (requiring a lift function)\nObject Construction:\nFor dictionary-like types: Create an empty dictionary and add key-value pairs\nFor array-like types: Create an empty array and push values\nFor no-arg types: Create an empty instance and set fields\nFor regular structs: Collect field values and call the constructor\nFor primitive types: Use lift to convert the source value\nField Mapping:\nMatch source keys to target fields, respecting field tags\nConvert values to appropriate field types\nHandle missing values, defaults, and special types","category":"page"},{"location":"#Implementing-StructUtils-Interfaces","page":"StructUtils.jl Documentation","title":"Implementing StructUtils Interfaces","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"To make your types work well with StructUtils.jl, you can implement several interfaces:","category":"page"},{"location":"#Type-Classification","page":"StructUtils.jl Documentation","title":"Type Classification","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"These functions determine how your type is handled by make:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"# For dictionary-like types\nStructUtils.dictlike(::Type{MyDict}) = true\n\n# For array-like types\nStructUtils.arraylike(::Type{MyArray}) = true\n\n# For types with empty constructors\nStructUtils.noarg(::Type{MyType}) = true\n\n# For types with keyword constructors\nStructUtils.kwdef(::Type{MyType}) = true","category":"page"},{"location":"#Value-Conversion","page":"StructUtils.jl Documentation","title":"Value Conversion","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"These functions control how values are converted during serialization/deserialization:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"# Convert a source value to your type\nStructUtils.lift(::Type{MyType}, x) = MyType(x)\n\n# Convert a key to your type (for dictionary keys)\nStructUtils.liftkey(::Type{MyType}, x::String) = MyType(parse(Int, x))\n\n# Convert your type to a serializable form\nStructUtils.lower(x::MyType) = string(x)\n\n# Convert your type to a serializable key\nStructUtils.lowerkey(x::MyType) = string(x)","category":"page"},{"location":"#Field-Metadata","page":"StructUtils.jl Documentation","title":"Field Metadata","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"These functions control field behavior:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"# Define default values for fields\nStructUtils.fielddefaults(::StructUtils.StructStyle, ::Type{MyType}) = (field1=1, field2=\"default\")\n\n# Define tags for fields\nStructUtils.fieldtags(::StructUtils.StructStyle, ::Type{MyType}) = (field1=(name=\"f1\",), field2=(ignore=true,))\n\n# Define a namespace for field tags\nStructUtils.fieldtagkey(::MyStyle) = :mylib","category":"page"},{"location":"#Advanced-Features","page":"StructUtils.jl Documentation","title":"Advanced Features","text":"","category":"section"},{"location":"#Type-Selection-for-Abstract-Types","page":"StructUtils.jl Documentation","title":"Type Selection for Abstract Types","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"When working with abstract types, you need a way to determine the concrete type to construct. The @choosetype macro helps with this:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"abstract type Vehicle end\nstruct Car <: Vehicle; make::String; model::String; end\nstruct Truck <: Vehicle; make::String; model::String; payload::Float64; end\n\n# Define how to choose concrete types based on source data\nStructUtils.@choosetype Vehicle x -> x[\"type\"] == \"car\" ? Car : Truck\n\n# Now make can create the right type\ncar = StructUtils.make(Vehicle, Dict(\"type\" => \"car\", \"make\" => \"Toyota\", \"model\" => \"Corolla\"))","category":"page"},{"location":"#The-Selectors-Module","page":"StructUtils.jl Documentation","title":"The Selectors Module","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"StructUtils includes a Selectors module that provides a powerful way to query objects:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"using StructUtils.Selectors\n\n# Create a nested structure\ndata = Dict(\"users\" => List([\n    Dict(\"id\" => 1, \"name\" => \"Alice\"),\n    Dict(\"id\" => 2, \"name\" => \"Bob\")\n]))\n\n# Query with selectors\nusers = data[\"users\"]  # Get the users array\nnames = users[:].name  # Get all user names","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The selector syntax supports various operations:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"x[\"key\"] / x.key - Select by key\nx[:] - Select all values\nx[~, \"key\"] - Recursively select all values with key\nx[:, (k,v) -> Bool] - Filter by predicate","category":"page"},{"location":"#Non-Struct-Like-Structs-with-@nonstruct","page":"StructUtils.jl Documentation","title":"Non-Struct-Like Structs with @nonstruct","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"What if you have a custom struct that you want behave more like a primitive type rather than a struct?","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The @nonstruct macro is perfect for this use case. By marking your struct as non-struct-like, you tell StructUtils to treat it as a primitive type that should be converted directly using lift and lower methods rather than constructing it from field values.","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Here's an example of a custom email type that should be serialized as a JSON string:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"@nonstruct struct Email\n    value::String\n    \n    function Email(value::String)\n        # Validate email format\n        if !occursin(r\"^[^@]+@[^@]+\\.[^@]+$\", value)\n            throw(ArgumentError(\"Invalid email format: $value\"))\n        end\n        new(value)\n    end\nend\n\n# Define how to convert from various sources to Email\nStructUtils.lift(::Type{Email}, x::String) = Email(x)\n\n# Define how to convert Email to a serializable format\nStructUtils.lower(x::Email) = x.value\n\n# Now you can use Email in your structs and it will be serialized as a string\n@defaults struct User\n    id::Int = 1\n    name::String = \"default\"\n    email::Email\nend\n\n# Create a user with an email\nuser = User(email=Email(\"alice@example.com\"))\n\n# Convert to Dict - email will be a string, not an object\ndict = StructUtils.make(Dict{String,Any}, user)\n# Result: Dict(\"id\" => 1, \"name\" => \"default\", \"email\" => \"alice@example.com\")\n\n# Convert back from Dict\nuser_again = StructUtils.make(User, dict)","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Another example - a custom numeric type that represents a percentage:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"@nonstruct struct Percent <: Number\n    value::Float64\n    \n    function Percent(value::Real)\n        if value < 0 || value > 100\n            throw(ArgumentError(\"Percentage must be between 0 and 100\"))\n        end\n        new(Float64(value))\n    end\nend\n\n# Convert from various numeric types\nStructUtils.lift(::Type{Percent}, x::Number) = Percent(x)\nStructUtils.lift(::Type{Percent}, x::String) = Percent(parse(Float64, x))\n\n# Convert to a simple number for serialization\nStructUtils.lower(x::Percent) = x.value\n\n# Use in a struct\n@defaults struct Product\n    name::String = \"default\"\n    discount::Percent = Percent(0.0)\nend\n\n# Create and serialize\nproduct = Product(discount=Percent(15.5))\ndict = StructUtils.make(Dict{String,Any}, product)\n# Result: Dict(\"name\" => \"default\", \"discount\" => 15.5)","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"The key points about @nonstruct:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"No field defaults or tags: Since you're opting out of struct-like behavior, field defaults and tags are not supported.\nRequires lift and lower methods: You must define how to convert to/from your type.\nFields are private: The struct's fields are considered implementation details for the make process.\nPerfect for wrapper types: Great for types that wrap primitives but need custom validation or behavior.","category":"page"},{"location":"#Complex-Example","page":"StructUtils.jl Documentation","title":"Complex Example","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Let's put everything together in a complex example, similar to the FrankenStruct example in the JSON.jl documentation:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"using Dates, StructUtils\n\n# Abstract type for polymorphism\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\n# Type chooser for AbstractMonster\nStructUtils.@choosetype AbstractMonster x -> \n    x isa Dict && haskey(x, \"monster_type\") && x[\"monster_type\"] == \"vampire\" ? \n    Dracula : Werewolf\n\n# Custom numeric type with special parsing\nstruct Percent <: Number\n    value::Float64\nend\n\n# Custom value lifting\nStructUtils.lift(::Type{Percent}, x::Number) = Percent(Float64(x))\nStructUtils.liftkey(::Type{Percent}, x::String) = Percent(parse(Float64, x))\n\n# Our complex struct with various field types and defaults\n@defaults struct FrankenStruct\n    id::Int = 0\n    name::String = \"Jim\"\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = nothing\n    monster::AbstractMonster = Dracula(0)\n    percent::Percent = Percent(0.0)\n    birthdate::Date = Date(0) &(dateformat=\"yyyy/mm/dd\",)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}()\n    matrix::Matrix{Float64} = Matrix{Float64}(undef, 0, 0)\nend\n\n# Create a FrankenStruct from a nested dictionary\nsource = Dict(\n    \"id\" => 1,\n    \"address\" => \"123 Main St\",\n    \"franken_type\" => \"b\",\n    \"monster\" => Dict(\"monster_type\" => \"vampire\", \"num_victims\" => 10),\n    \"percent\" => 0.1,\n    \"birthdate\" => \"2023/10/01\",\n    \"percentages\" => Dict(\"0.1\" => 1, \"0.2\" => 2),\n    \"matrix\" => [[1.0, 2.0], [3.0, 4.0]]\n)\n\n# Create a FrankenStruct from the source\nfrankenstein = StructUtils.make(FrankenStruct, source)\n\n# Convert it back to a dictionary\ndict_again = StructUtils.make(Dict{String,Any}, frankenstein)","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"In this example:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"We define a polymorphic type hierarchy with AbstractMonster\nWe implement custom type selection using @choosetype\nWe define a custom numeric type Percent with special parsing\nWe create a complex struct with various field types and tags\nWe use make to create an instance from a nested dictionary","category":"page"},{"location":"#Summary","page":"StructUtils.jl Documentation","title":"Summary","text":"","category":"section"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"StructUtils.jl provides a comprehensive suite of tools for working with Julia structs:","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"Struct definition macros enhance structs with special behaviors:\n@noarg - No-argument constructor for mutable structs\n@defaults - Default values for struct fields\n@kwarg - Keyword constructor\n@tags - Field metadata\nField tags provide metadata for fields:\nname - Alternative name\nignore - Skip during serialization/deserialization\ndateformat - Format for date fields\nlift/lower - Custom conversion functions\nThe make function converts between different data representations:\nDict → Struct\nStruct → Dict\nStruct → NamedTuple\nArray → Vector\netc.\nCustom interfaces allow for specialized behavior:\nType classification (dictlike, arraylike, etc.)\nValue conversion (lift, lower, etc.)\nField metadata (fielddefaults, fieldtags, etc.)","category":"page"},{"location":"","page":"StructUtils.jl Documentation","title":"StructUtils.jl Documentation","text":"StructUtils.jl integrates well with other packages like JSON.jl for seamless serialization and deserialization of complex Julia types.","category":"page"}]
}
